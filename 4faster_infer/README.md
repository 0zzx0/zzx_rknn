

## 对比
正常：29.63
不加后处理：29.17ms
不加预处理：23.48ms
only run: 22.3ms



推理延迟：图片从诞生到推理完成需要的时间。（实时性）
吞吐量：相等时间内处理图片的数量。

机器人目标检测使用多线程的意义：
    首先毫无疑问就是为了加速，这里说的加速并不是值推理加速，因为那部分是模型推理框架做的比如ncnn、tensorrt、rknn等，他们也许内部也会有多线程的操作，但是一般来说我们比较难控制，尤其是trt、rknn这种闭源的框架。所以这个加速是指，可以在相等时间内推理好更多图片，也就是增加模型的吞吐量。这里我预想了两种情景：

1. 多摄像头输入。当前实际上这种情景可能更适合batch输入，效果肯定是比多线程好的。但是如果不同摄像头检测的目标不一致或者执行其他的比如分类分割任务等，这个时候很明显最优的方法就是多线程并行了，但是本项目不适合此种场景，因为本项目知识单模型多线程。

2. 输入帧率高。输入帧率特别高，要不就是把输入都先存下来，然后慢慢推理，但是这样完全没有意义了，因为现在的结果很可能是几年前采集的(bushi)。当然可以选择跳过一些帧，但是这样毕竟是会丢失一些信息，


于是本项目就有了一小点点意义，使用折中的方案，利用多线程重合不同图片之间的预加载过程(应该还有多线程并行推理)，最终实现推理延迟不增加的情况下，增加吞吐量，其中优先考虑推理延迟，因为实时性才是重中之重。

当前常见多线程的问题：
    预加载：只考虑吞吐量不考虑推理延迟，造成无法实时推理。
    多模型线程：每个线程创建一个推理器，造成内存消耗较大


思路一（已经完成）：
    生产者线程：commit img + preproccess
    消费者线程：infer img + postprocess
    （图片间隔 + 预处理） 约等于 （图像推理 + 后处理时间） 可以得到在推理延迟基本不变的条件下，图片吞吐量的最大化。

思路二：
    一条生产者线程
    多条消费者线程（共享模型权重，单独有自己的输入输出内存）

